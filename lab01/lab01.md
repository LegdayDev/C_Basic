## C 사전지식

### 컴퓨터와 2진법
- `1bit`는 전기 스위치 1개를 의미한다.
- 스위치가 On 상태는 1, 흐르지 않는 Off 상태는 0 으로 표기
- 여러 스위치(혹은 전선)를 4개씩 묶어주면 4bit
- 즉, 0과 1을 표현하는 2가지의 상태를 표현할려면 2진법을 사용하는게 최적이다.
- 하지만 수가 커질수록 2진수를 끝도없이 길어진다, 그래서 16진법이 나왔다.

  <img src="/etc/img.png" width="600" height="400">

- 위 그림에서 2진법으로 1001 이라 되어있는데 **우측부터 좌측으로 각 자리는 2의 0승, 2의 1승, ... , 2의 n 승**이라고 생각하면 된다.
- 2진법 1001은 10진법으로 나타내면 `(2의3승*1) + (2의2승*0) + (2의1승*0) + (2의0승*1) = 9` 이다.

### 디지털 게이트 회로
<img src="/etc/img02.png" width="600" height="400">

- C언어의 연산자를 이해하기 위해서 게이트 회로를 알고 있어야 한다.
- A와B는 각 Input 데이터이고 `AND`, `OR`, `XOR` 에 따라서 S 라는 Output 데이터가 출력된다.
- 위 예제는 1bit 를 기준으로 계산되어있지만, _최소 4bit 의 데이터로 연산하는 방법을 알아야 한다._
- 만약 2진수 A(1001) 과 B(1100) 을 AND 연산을 하면 다음과 같다.
  - 좌측부터 A의 1 과 B의 1을 AND 연산하면 1
  - A의 0과 B의 1을 ANd 연산하면 0
  - A의 0과 B의 0을 AND 연산하면 0
  - A의 1과 B의 0을 AND 연산하면 0
  - 즉, 1001 과 1100을 AND 연산하면 1000 이 된다.

### 가산기와 수제 CPU
> 컴퓨터는 덧셈만 가능하면 계산기를 만들 수 있다.

#### 반가산기
<img src="/etc/img03.png" width="475" height="307">

- 위 그림에서 위에 있는 게이트회로는 `XOR` 이고, 아래는 `AND` 이다.
- 만약 A가 1, B가 1 이면 XOR 연산에 의해 S 는 0이고, AND 연산에 의해 C는 1이 된다.
- 이 때, **C는 올림(Carry)**이다.
- 그래서 2진수 10 이 나오게 된다. 이렇게 2개의 게이트회로로 계산기를 만들 수 있다.
- 하지만 반가산기의 치명적인 단점은 4bit일 때 나타나게 된다.
  - 4bit 계산에서 2진수 1과 1을 AND 연산을 하면 올림수 1이 발생한다. 그러면 다음 자리수 계산할때 Input 데이터가 3개가 된다.
  - 하지만 반가산기에는 2개의 Input만 받을 수 있기 때문에 게산이 안된다.
  - 반가산기의 단점을 극복하기 위해 전가산기가 나왔다.

#### 전가산기
<img src="/etc/img04.png" width="475" height="307">

- 이제는 **올림수(Carry)를 감안해서 Input 데이터가 3개가 되고 몇개의 게이트회로가 추가**되었다.
- 계산할 때마다 올림수와 Input 데이터 2개를 감안하여 계산하면 4bit보다 더 큰 bit의 계산도 가능하다.
  
  <img src="/etc/img05.png" width="604" height="241">

- 위 그림을 참고해서 2진수 A(1001) 과 B(1101)을 계산하면 다음과 같다.
  - 우측끝부터 A의 1 과 B의 1을 더하면 올림수 1이 발생하고 0 이 된다.
  - 첫번째 계산해서 발생한 올림수 1과 A의 0 , B의 0을 더하면 1이 된다.
  - A의 0과 B의 1을 더하면 1이 된다.
  - A의 1과 B의 1을 더하면 올림수 1이 발생하고 0이 된다.
  - 마지막 계산에 올림수 1을 포함해서 10110 이 된다.
  - 10진수 A는 9 이고, B는 13인데 더하면 22이 된다. 21의 2진수는 22이다.